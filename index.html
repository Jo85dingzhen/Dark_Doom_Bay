<!doctype html><html><head><meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,viewport-fit=cover">
<style>
html,body{margin:0;padding:0;width:100%;height:100%;overflow:hidden;background:#000}
body{position:fixed;inset:0;touch-action:none;-webkit-user-select:none;user-select:none;-webkit-touch-callout:none}
canvas{display:block;width:100vw;height:100vh;image-rendering:auto}
</style></head><body><canvas id="c"></canvas><script>
const C=document.getElementById("c"),X=C.getContext("2d"),P=document.createElement("canvas"),PX=P.getContext("2d");
let W=0,H=0,pw=320,ph=180,scale=1,ox=0,oy=0;
function rs(){
  W=innerWidth;H=innerHeight;
  pw=320;ph=(pw*H/W)|0;
  P.width=pw;P.height=ph;
  scale=Math.max(1,Math.min((W/pw)|0,(H/ph)|0));
  ox=((W-pw*scale)/2)|0;oy=((H-ph*scale)/2)|0;
  C.width=W;C.height=H;C.style.width=W+"px";C.style.height=H+"px";
  X.setTransform(1,0,0,1,0,0);
  X.imageSmoothingEnabled=false;PX.imageSmoothingEnabled=false;
}
rs();addEventListener("resize",rs);addEventListener("orientationchange",()=>setTimeout(rs,80));
addEventListener("scroll",()=>scrollTo(0,0),{passive:true});

const clamp=(v,a,b)=>v<a?a:v>b?b:v;
const dist2=(ax,ay,bx,by)=>{let dx=ax-bx,dy=ay-by;return dx*dx+dy*dy};
const TAU=Math.PI*2;
function pal(c,k){const r=parseInt(c.slice(1,3),16),g=parseInt(c.slice(3,5),16),b=parseInt(c.slice(5,7),16);const m=30;return`rgb(${(r*k+m)|0},${(g*k+m)|0},${(b*k+m)|0})`}

// ===== AUDIO =====
const actx=new(window.AudioContext||window.webkitAudioContext)();
function beep(freq,dur,vol,type){try{const o=actx.createOscillator(),g=actx.createGain();o.type=type||"square";o.frequency.value=freq;g.gain.value=vol||.08;o.connect(g);g.connect(actx.destination);o.start();g.gain.exponentialRampToValueAtTime(.001,actx.currentTime+dur);o.stop(actx.currentTime+dur)}catch(e){}}
function sfxShoot(){beep(220,.08,.1)}
function sfxExec(){beep(880,.15,.12);beep(1100,.1,.1)}
function sfxHit(){beep(110,.12,.08,"sawtooth")}
function sfxTick(){beep(60,.3,.1,"sawtooth")}
function sfxDoor(){beep(440,.2,.08);beep(660,.15,.08)}
function sfxBtn(){beep(330,.06,.06)}

// ===== WEAPONS =====
const WEAPONS=[
 {id:"MIN",name:"Min Pay",shotCost:6,damage:18,fireMs:140,settleCap:22,desc:"Low cost, suppresses interest"},
 {id:"INST",name:"Installment",shotCost:14,damage:45,fireMs:220,settleCap:60,desc:"Balanced damage"},
 {id:"SET",name:"Settle",shotCost:60,damage:220,fireMs:520,settleCap:260,desc:"High damage, execute"}
];
let curW=0;

// ===== ENEMY TYPES =====
const TYPES={
 sub:{n:"SUB",c:"#4caf50",spd:.55},
 util:{n:"UTIL",c:"#90a4ae",spd:.52},
 bonus:{n:"BONUS",c:"#ffd700",spd:.35},
 cred:{n:"CRED",c:"#e53935",spd:.62},
 bnpl:{n:"BNPL",c:"#9c27b0",spd:.48},
 rent:{n:"RENT",c:"#1e88e5",spd:.32},
 med:{n:"MED",c:"#8e24aa",spd:.42},
 latefee:{n:"LATE",c:"#ff5722",spd:.85}
};

const TICK=10;

// ===== LEVELS =====
const LVLS=[
 {name:"MOSS DUNGEON",wall:"#3a5a2b",ceil:"#1a2a10",floor:"#2a3a1a",fog:"#0a120a",vis:1.0,
  map:[
"1111111111111111",
"1..0....0......1",
"1..0.1110.1111.1",
"1..0....0....1.1",
"1..011110.0..1.1",
"1......0..0..1.1",
"1.111..0.11111.1",
"1....0.0.....0.1",
"1....0.0111110.1",
"1....0.0.....0.1",
"1....0.0..1110.1",
"1....0.0....00.1",
"1....0.0111110.1",
"1..............1",
"1............E.1",
"1111111111111111"],
  sp:{x:2.5,y:2.5,a:.2}},
 {name:"ASH DUNGEON",wall:"#4a4a4a",ceil:"#1a1a1a",floor:"#2a2a2a",fog:"#090909",vis:.78,
  map:[
"1111111111111111",
"1......0....0..1",
"1.1111.0.11.0..1",
"1.0....0..0.0..1",
"1.0.1111110.11.1",
"1.0....0..0..0.1",
"1.0111.0.0111..1",
"1....0.0....0..1",
"1.1110.011110..1",
"1....0.....0.0.1",
"1.1110111110.0.1",
"1....0.....0.0.1",
"1.1110.11110.0.1",
"1.....0.....0..1",
"1...........0E.1",
"1111111111111111"],
  sp:{x:2.5,y:2.5,a:.1}},
 {name:"INFERNO DUNGEON",wall:"#4a0a0a",ceil:"#1a0000",floor:"#2a0a0a",fog:"#050000",vis:.65,
  map:[
"1111111111111111",
"1..0....0....0.1",
"1..0.1110.11.0.1",
"1..0...00..0.0.1",
"1.1111.1110.0..1",
"1....0....0.0..1",
"1.1100.1110.01.1",
"1...0....0..0..1",
"1.1.011110.011.1",
"1.1.0....0...0.1",
"1.1.0.11101111.1",
"1...0....0...0.1",
"1.11111110.110.1",
"1........0...0.1",
"1............E.1",
"1111111111111111"],
  sp:{x:2.5,y:2.5,a:0}}
];

// ===== LEVEL ENEMY CONFIG =====
const LEVEL_CONFIG=[
  {// Level 1 - Moss: sub x7, util x6, bonus x2
    types:[
      {t:"sub",  count:7, Pmin:40, Pmax:120,rmin:1.0,rmax:1.6},
      {t:"util", count:6, Pmin:60, Pmax:140,rmin:.8, rmax:1.3},
      {t:"bonus",count:2, Pmin:30, Pmax:60, rmin:0,  rmax:0,  reward:[80,150]}
    ]},
  {// Level 2 - Ash: cred x5, sub x6, bnpl x4
    types:[
      {t:"cred", count:5, Pmin:120,Pmax:240,rmin:1.8,rmax:2.6,projDmg:[10,25]},
      {t:"sub",  count:6, Pmin:60, Pmax:160,rmin:1.2,rmax:1.9},
      {t:"bnpl", count:4, Pmin:100,Pmax:220,rmin:1.4,rmax:2.2}
    ]},
  {// Level 3 - Inferno: rent x4, med x4, latefee x7
    types:[
      {t:"rent",   count:4, Pmin:280,Pmax:600,rmin:1.6,rmax:2.4},
      {t:"med",    count:4, Pmin:160,Pmax:360,rmin:1.8,rmax:2.8},
      {t:"latefee",count:7, Pmin:60, Pmax:150,rmin:2.6,rmax:4.0}
    ]}
];

function rng(a,b){return a+Math.random()*(b-a)}
function rngI(a,b){return(a+Math.random()*(b-a))|0}

// find walkable cells in a map (cells that are '.' or 'E'), excluding player start area
function findSpawns(m,spx,spy,n){
  const spots=[];
  for(let y=0;y<m.length;y++)for(let x=0;x<m[y].length;x++){
    const c=m[y][x];
    if(c==="."||c==="E"){
      const dx=x+.5-spx,dy=y+.5-spy;
      if(dx*dx+dy*dy>4) spots.push({x:x+.5,y:y+.5});
    }
  }
  // shuffle
  for(let i=spots.length-1;i>0;i--){const j=(Math.random()*(i+1))|0;[spots[i],spots[j]]=[spots[j],spots[i]]}
  return spots.slice(0,n);
}

function spawnWave(lvlIdx){
  const cfg=LEVEL_CONFIG[lvlIdx];
  const L=LVLS[lvlIdx];
  const spots=findSpawns(L.map,L.sp.x,L.sp.y,15);
  const enemies=[];
  let si=0;
  for(const tc of cfg.types){
    for(let i=0;i<tc.count;i++){
      const pos=spots[si++]||{x:3+Math.random()*8,y:3+Math.random()*8};
      const P=rngI(tc.Pmin,tc.Pmax);
      const r=rng(tc.rmin,tc.rmax);
      const tp=TYPES[tc.t];
      const e={t:tc.t,x:pos.x,y:pos.y,P:P,P0:P,r:r,spd:tp.spd,cd:0,due:0,
        sh:tc.t==="med"?1:0,shi:tc.t==="med"?1:0,
        atk:0,split:tc.t==="sub"?1:0,small:0,supT:0,
        reward:tc.reward?rngI(tc.reward[0],tc.reward[1]):0,
        projDmg:tc.projDmg?rng(tc.projDmg[0],tc.projDmg[1]):0,
        futureFee:0};
      enemies.push(e);
    }
  }
  // randomly mark exactly 5 as TODAY DUE
  const idx=[];for(let i=0;i<enemies.length;i++)idx.push(i);
  for(let i=idx.length-1;i>0;i--){const j=(Math.random()*(i+1))|0;[idx[i],idx[j]]=[idx[j],idx[i]]}
  for(let i=0;i<5;i++) enemies[idx[i]].due=1;
  return enemies;
}

// ===== TUTORIAL MAP =====
const TUT_MAP=[
"11111111",
"1......1",
"1......1",
"1......1",
"1......1",
"1....E.1",
"1......1",
"11111111"
];

// ===== STATE =====
let state="MENU"; // MENU,TUTORIAL,GAME,WIN,LOSE
let lvl=0,map=[],MW=0,MH=0;
let px=2.5,py=2.5,pa=0;
let bal=3000,alive=[],needDue=0,doorOpen=0;
let tick=TICK,flash=0,shakeT=0,dmgFlash=0;
let ex=0,ey=0;
function findExit(){for(let y=0;y<MH;y++)for(let x=0;x<MW;x++)if(map[y][x]==="E"){ex=x+.5;ey=y+.5;return}}
let stormT=0,stormOn=0;
let projs=[];
let tutStep=0,tutDone=0,tutTimer=0,tutShotFired=0;
let totalTime=0,finalBal=0;
let menuSel=-1;
let recoilT=0,muzzleT=0;

function spawnProj(x,y,vx,vy,rate){projs.push({x,y,vx,vy,life:3,rate})}

function loadLevel(i){
  lvl=i;const L=LVLS[i];
  map=L.map;MH=map.length;MW=map[0].length;
  px=L.sp.x;py=L.sp.y;pa=L.sp.a;
  bal=3000;tick=TICK;flash=0;doorOpen=0;
  projs=[];stormT=0;stormOn=0;
  alive=spawnWave(i);
  needDue=0;
  for(const e of alive) if(e.due) needDue++;
  findExit();
}

function loadTutorial(){
  state="TUTORIAL";tutStep=0;tutShotFired=0;tutTimer=0;
  map=TUT_MAP;MH=map.length;MW=map[0].length;
  px=1.5;py=1.5;pa=.5;bal=500;tick=99;flash=0;doorOpen=0;
  alive=[];needDue=0;projs=[];stormT=0;stormOn=0;curW=0;
  alive.push({t:"sub",x:5.5,y:3.5,P:20,P0:20,r:.1,spd:.15,cd:0,due:1,
    sh:0,shi:0,atk:0,split:0,small:0,supT:0,reward:0,projDmg:0,futureFee:0});
  needDue=1;
  findExit();
}

function cell(x,y){if(x<0||y<0||x>=MW||y>=MH)return"1";return map[y][x]}
function isWall(x,y){const c=cell(x|0,y|0);if(c==="1")return 1;if(c==="E")return doorOpen?0:1;return 0}
function tryMove(nx,ny){const r=.18;if(!isWall(nx+r,py)&&!isWall(nx-r,py))px=nx;if(!isWall(px,ny+r)&&!isWall(px,ny-r))py=ny}
function dueLeft(){let c=0;for(const e of alive)if(e.P>0&&e.due)c++;return c}

// ===== INPUT =====
let fireHold=0,fireId=-1,joyId=-1,lookId=-1;
let moveX=0,moveY=0,joyCx=0,joyCy=0,lookPX=0;
let fireCd=0,dtCur=.016;
let tapX=-1,tapY=-1,tapped=0;

function JX(){return W*.18}function JY(){return H*.82}
function JR(){return Math.min(W,H)*.12}
function FR(){return Math.min(W,H)*.085}
function FX(){return W*.84}function FY(){return H*.82}

function pickWeaponAt(x,y){
  if(state!=="GAME"&&state!=="TUTORIAL")return 0;
  const bw=62,bh=28,by=6,bx0=W*.5-(bw*3+10*2)/2;
  for(let i=0;i<3;i++){
    const bx=bx0+i*(bw+10);
    if(x>=bx&&x<=bx+bw&&y>=by&&y<=by+bh){curW=i;sfxBtn();return 1}
  }
  return 0
}

function endIds(e){
  for(const ct of e.changedTouches){
    const id=ct.identifier;
    if(id===joyId){joyId=-1;moveX=moveY=0}
    if(id===fireId){fireId=-1;fireHold=0}
    if(id===lookId){lookId=-1}
  }
}

function menuHit(x,y){
  const bw=200,bh=44,bx=W/2-bw/2;
  const labels=["START","TUTORIAL","OPTIONS"];
  for(let i=0;i<3;i++){
    const by=H*.45+i*60;
    if(x>=bx&&x<=bx+bw&&y>=by&&y<=by+bh){sfxBtn();return i}
  }
  return-1
}

function endScreenHit(x,y){
  const bw=180,bh=44,bx=W/2-bw/2;
  const by1=H*.55,by2=H*.55+56;
  if(x>=bx&&x<=bx+bw&&y>=by1&&y<=by1+bh)return 0;
  if(x>=bx&&x<=bx+bw&&y>=by2&&y<=by2+bh)return 1;
  return-1
}

function handleTouch(e){
  e.preventDefault();
  if(e.type==="touchend"||e.type==="touchcancel"){
    endIds(e);
    // tap detection for menus
    for(const ct of e.changedTouches){
      tapX=ct.clientX;tapY=ct.clientY;tapped=1;
    }
  }
  const ts=e.touches;
  if(joyId<0)moveX=moveY=0;
  if(fireId<0)fireHold=0;

  if(state==="GAME"||state==="TUTORIAL"){
    if(e.type==="touchstart"){
      for(const t of e.changedTouches){
        const x=t.clientX,y=t.clientY,id=t.identifier;
        if(pickWeaponAt(x,y))continue;
        if(fireId<0&&dist2(x,y,FX(),FY())<FR()*FR()*2){fireId=id;fireHold=1;continue}
        if(joyId<0&&x<W*.5&&y>H*.4){joyId=id;joyCx=JX();joyCy=JY();continue}
        if(lookId<0){lookId=id;lookPX=x;continue}
      }
    }
    for(const t of ts){
      const id=t.identifier,x=t.clientX,y=t.clientY;
      if(id===fireId)fireHold=1;
      if(id===joyId){
        const r=JR(),dx=x-joyCx,dy=y-joyCy;
        moveX=clamp(dx/r,-1,1);moveY=clamp(-dy/r,-1,1);
        if(Math.abs(moveX)<.08)moveX=0;
        if(Math.abs(moveY)<.08)moveY=0;
      }
      if(id===lookId){pa+=((x-lookPX)/W)*6.5*(dtCur*60);lookPX=x}
    }
  }
}
C.addEventListener("touchstart",handleTouch,{passive:false});
C.addEventListener("touchmove",handleTouch,{passive:false});
C.addEventListener("touchend",handleTouch,{passive:false});
C.addEventListener("touchcancel",handleTouch,{passive:false});

// desktop
let mLook=0,mLastX=0,keys={};
addEventListener("keydown",e=>{keys[e.key.toLowerCase()]=1;if(e.key===" ")fireHold=1});
addEventListener("keyup",e=>{keys[e.key.toLowerCase()]=0;if(e.key===" ")fireHold=0});
C.addEventListener("mousedown",e=>{
  if(state==="MENU"||state==="WIN"||state==="LOSE"){tapX=e.clientX;tapY=e.clientY;tapped=1;return}
  if(pickWeaponAt(e.clientX,e.clientY))return;
  mLook=1;mLastX=e.clientX
});
addEventListener("mouseup",()=>{mLook=0});
addEventListener("mousemove",e=>{if(mLook){pa+=(e.clientX-mLastX)/W*6.5*(dtCur*60);mLastX=e.clientX}});

// ===== RAYCAST =====
function raycast(a){let x=px,y=py,dx=Math.cos(a),dy=Math.sin(a),d=0,s=.02;for(let i=0;i<1200;i++){x+=dx*s;y+=dy*s;d+=s;if(isWall(x,y))return d}return 20}
function pickTarget(){
  let best=-1,bd=1e9;
  for(let i=0;i<alive.length;i++){
    const e=alive[i];if(e.P<=0)continue;
    const vx=e.x-px,vy=e.y-py,d=Math.hypot(vx,vy);
    const ang=Math.atan2(vy,vx);
    let da=Math.abs(Math.atan2(Math.sin(ang-pa),Math.cos(ang-pa)));
    if(da<.18&&d<bd){bd=d;best=i}
  }
  return best
}

function killEnemy(e){
  if(e.due)needDue=Math.max(0,needDue-1);
  // bonus: reward player on kill
  if(e.t==="bonus"&&e.reward>0){bal+=e.reward;flash=.15;beep(660,.12,.1)}
  sfxExec();shakeT=.1;
  // sub split
  if(e.t==="sub"&&e.split&&!e.small){
    e.split=0;
    for(let k=0;k<2;k++){
      const p0=Math.max(15,(e.P0*.35)|0);
      alive.push({t:"sub",x:e.x+(k?.2:-.2),y:e.y+(k?.15:-.15),
        P:p0,P0:p0,r:TYPES.sub.r*.6||.4,spd:TYPES.sub.spd*1.3,cd:0,due:0,
        sh:0,shi:0,atk:0,split:0,small:1,supT:0,reward:0,projDmg:0,futureFee:0});
    }
  }
}

function shoot(){
  const w=WEAPONS[curW];
  if(bal<w.shotCost)return;
  const ti=pickTarget();
  bal-=w.shotCost;recoilT=.12;muzzleT=.08;sfxShoot();
  if(ti<0)return;
  const e=alive[ti];
  // suppress interest for MIN
  if(curW===0)e.supT=2;
  // execution line
  if(e.P<=w.settleCap&&bal>=0){e.P=0;killEnemy(e);shakeT=.15;flash=.2;return}
  // shield (medical)
  if(e.sh&&e.shi>0){e.shi=Math.max(0,e.shi-.45);sfxHit();return}
  // bnpl: on hit, rebound 5% of P back
  if(e.t==="bnpl"){
    const rebound=(e.P*.05)|0;
    e.P=Math.max(0,e.P-w.damage+rebound);
    e.futureFee=(e.futureFee||0)+1;
  }else{
    e.P=Math.max(0,e.P-w.damage);
  }
  if(e.P<=0){e.P=0;killEnemy(e)}
}

// ===== UPDATE =====
function updateGame(dt){
  let kx=0,ky=0;
  if(keys["w"]||keys["arrowup"])ky=1;
  if(keys["s"]||keys["arrowdown"])ky=-1;
  if(keys["a"]||keys["arrowleft"])kx=-1;
  if(keys["d"]||keys["arrowright"])kx=1;
  if(keys["1"])curW=0;if(keys["2"])curW=1;if(keys["3"])curW=2;
  const mx=moveX+kx,my=moveY+ky;
  const sp=2.2,fx=Math.cos(pa),fy=Math.sin(pa);
  const sx=Math.cos(pa+Math.PI/2),sy=Math.sin(pa+Math.PI/2);
  tryMove(px+(fx*my+sx*mx)*sp*dt,py+(fy*my+sy*mx)*sp*dt);

  totalTime+=dt;

  // interest tick
  tick-=dt;
  if(tick<=0){tick+=TICK;flash=.18;sfxTick()}

  // storm (level 3)
  stormOn=0;
  if(lvl===2){stormT+=dt;if(stormT%20>15)stormOn=1}

  // drain + enemy AI
  let mul=stormOn?2:1;
  for(const e of alive){
    if(e.P<=0)continue;
    if(e.sh&&e.shi<1)e.shi=Math.min(1,e.shi+dt*.08);
    // bonus enemies don't drain money
    if(e.t!=="bonus"){
      // bnpl: futureFee adds extra drain per hit taken
      const ffExtra=e.t==="bnpl"?(e.futureFee||0)*.3:0;
      if(e.supT>0){e.supT-=dt}else{bal-=(e.r+ffExtra)*mul*dt}
    }
    // chase
    const vx=e.x-px,vy=e.y-py,d=Math.hypot(vx,vy);
    if(d>.6){const nx=vx/d,ny=vy/d;const ex=e.x-nx*e.spd*dt,ey=e.y-ny*e.spd*dt;if(!isWall(ex,ey)){e.x=ex;e.y=ey}}
    // credit caster projectile
    if(e.t==="cred"&&e.P>0){
      e.atk=(e.atk||0)-dt;
      if(d<6&&d>1.2&&e.atk<=0){
        const nx=vx/d,ny=vy/d;
        spawnProj(e.x,e.y,-nx*3.2,-ny*3.2,e.projDmg||3.5);
        e.atk=1.3;
      }
    }
  }
  if(flash>0)flash=Math.max(0,flash-dt);
  if(shakeT>0)shakeT=Math.max(0,shakeT-dt);
  if(dmgFlash>0)dmgFlash=Math.max(0,dmgFlash-dt);
  if(recoilT>0)recoilT=Math.max(0,recoilT-dt);
  if(muzzleT>0)muzzleT=Math.max(0,muzzleT-dt);

  if(dueLeft()===0&&!doorOpen){doorOpen=1;sfxDoor()}

  // fire
  if(fireHold||keys[" "]){
    fireCd-=dt*1000;
    if(fireCd<=0){shoot();fireCd=WEAPONS[curW].fireMs}
  }else fireCd=0;

  // death (not during tutorial)
  if(state==="GAME"&&bal<=0){bal=0;state="LOSE";return}

  // exit (skip during tutorial â€” tutorial has its own exit handler)
  if(state==="GAME"&&doorOpen&&cell(px|0,py|0)==="E"){
    if(lvl<2){loadLevel(lvl+1)}
    else{finalBal=bal;state="WIN";return}
  }

  // projectiles
  for(let i=projs.length-1;i>=0;i--){
    const p=projs[i];
    p.x+=p.vx*dt;p.y+=p.vy*dt;p.life-=dt;
    if(isWall(p.x,p.y)||p.life<=0){projs.splice(i,1);continue}
    if(dist2(p.x,p.y,px,py)<.25){bal-=p.rate*1.5;dmgFlash=.12;sfxHit();projs.splice(i,1)}
  }
}

function updateTutorial(dt){
  updateGame(dt);
  tutTimer+=dt;
  const e=alive[0];
  if(tutStep===0){
    // Step 1: Move toward enemy
    if(e&&dist2(px,py,e.x,e.y)<6)tutStep=1;
  }else if(tutStep===1){
    // Step 2: waiting for first shot
    if(tutShotFired)tutStep=2;
  }else if(tutStep===2){
    // Step 3: execution line
    if(e&&e.P<=WEAPONS[curW].settleCap)tutStep=3;
  }else if(tutStep===3){
    // Step 4: enemy dead
    if(!e||e.P<=0){tutStep=4;doorOpen=1;sfxDoor()}
  }
}

// ===== DRAW HELPERS =====
function txt(s,x,y,c,f){X.fillStyle=c||"#fff";X.font=f||"14px monospace";X.fillText(s,x,y)}
function txtC(s,y,c,f){X.fillStyle=c||"#fff";X.font=f||"14px monospace";const m=X.measureText(s);X.fillText(s,W/2-m.width/2,y)}
function btn(label,x,y,w,h,fill,txtCol){
  X.fillStyle=fill||"#333";X.fillRect(x,y,w,h);
  X.strokeStyle="#888";X.lineWidth=1;X.strokeRect(x,y,w,h);
  X.fillStyle=txtCol||"#fff";X.font="16px monospace";
  const m=X.measureText(label);
  X.fillText(label,x+w/2-m.width/2,y+h/2+5);
}

// ===== DRAW GAME (raycasting) =====
function drawGame(){
  const L=state==="TUTORIAL"?{name:"TUTORIAL",wall:"#3a5a2b",ceil:"#1a2a10",floor:"#2a3a1a",fog:"#0a120a",vis:1}:LVLS[lvl];
  const shk=shakeT>0?(Math.random()-.5)*4:0;
  X.save();
  if(shk)X.translate(shk,shk);

  // ceiling
  X.fillStyle=L.ceil||pal(L.fog,.4);
  X.fillRect(0,0,W,H*.48);
  // ceiling grid
  X.fillStyle=pal(L.ceil||"#111",.8);
  for(let yy=0;yy<H*.48;yy+=12){for(let xx=0;xx<W;xx+=12){if(((xx/12|0)+(yy/12|0))%2===0){X.fillRect(xx,yy,12,12)}}}

  // floor
  X.fillStyle=L.floor||pal(L.fog,.5);
  X.fillRect(0,H*.52,W,H*.48);
  for(let yy=H*.52;yy<H;yy+=10){for(let xx=0;xx<W;xx+=10){const k=((xx/10|0)+(yy/10|0))%2?.7:.8;X.fillStyle=pal(L.floor||"#222",k);X.fillRect(xx,yy,10,10)}}

  // raycast walls
  const rw=220,rh=140,fov=1.1;
  const sxR=W/rw,syR=H/rh;
  const depth=new Array(rw);
  for(let i=0;i<rw;i++){
    const a=pa+(i/rw-.5)*fov;
    const d=raycast(a);depth[i]=d;
    const fog=clamp(1-d/10,0,1)*L.vis;
    const h=(rh/(d+.0001))*.9;
    const y0=(rh-h)/2;
    // wall
    X.fillStyle=pal(L.wall,fog);
    X.fillRect(i*sxR,y0*syR,sxR+1,h*syR);
    // brick lines
    if((i>>1)%4===0){X.fillStyle=pal("#000",fog*.3);X.fillRect(i*sxR,y0*syR,1,h*syR)}
    // horizontal brick lines
    const brickH=h*syR/4;
    for(let b=1;b<4;b++){
      X.fillStyle=pal("#000",fog*.15);
      X.fillRect(i*sxR,y0*syR+b*brickH,sxR+1,1);
    }
  }

  // enemies (sprites)
  let spr=[];
  for(const e of alive){
    if(e.P<=0)continue;
    const vx=e.x-px,vy=e.y-py,d=Math.hypot(vx,vy);
    const ang=Math.atan2(vy,vx);
    let da=Math.atan2(Math.sin(ang-pa),Math.cos(ang-pa));
    if(Math.abs(da)>fov*.6)continue;
    spr.push({e,d,da});
  }
  spr.sort((a,b)=>b.d-a.d);

  for(const s of spr){
    const {e,d,da}=s;const tp=TYPES[e.t];
    const cx=(0.5+da/fov)*rw;
    const di=Math.max(0,Math.min(rw-1,cx|0));
    if(d>depth[di])continue;
    const size=clamp(80/d,10,80);
    const sx0=(cx-size/2)*sxR;
    const sy0=(rh/2-size*.7)*syR;
    const fog=clamp(1-d/10,0,1)*L.vis;
    const w=WEAPONS[curW];
    const exec=(e.P<=w.settleCap&&bal>=w.shotCost);

    const ecx=sx0+size*sxR/2,ecy=sy0+size*syR/2;
    const squish=Math.sin(performance.now()*.006+e.x*2)>.0?.92:1;

    if(e.t==="bonus"){
      // chest/box shape
      X.fillStyle=pal("#ffd700",fog);
      X.fillRect(sx0+size*sxR*.15,sy0+size*syR*.2,size*sxR*.7,size*syR*.6);
      X.fillStyle=pal("#ffb300",fog);
      X.fillRect(sx0+size*sxR*.15,sy0+size*syR*.2,size*sxR*.7,size*syR*.15);
      // sparkle
      if(Math.sin(performance.now()*.01+e.y)>.5){
        X.fillStyle="rgba(255,255,200,"+(fog*.6)+")";
        X.fillRect(ecx-2,ecy-size*syR*.4,4,4);
      }
    }else{
      // slime body
      X.fillStyle=pal(tp.c,fog);
      X.beginPath();
      X.ellipse(ecx,ecy,size*sxR/2,size*syR/2*squish,0,0,TAU);
      X.fill();
    }

    // shield (medical)
    if(e.sh&&e.shi>0){
      X.strokeStyle=pal("#ce93d8",fog);X.lineWidth=3;
      X.beginPath();X.arc(ecx,ecy,size*sxR/2+4,0,TAU*e.shi);X.stroke();
    }

    // execution gold outline
    if(exec){
      X.strokeStyle="#ffd700";X.lineWidth=2;
      X.beginPath();X.ellipse(ecx,ecy,size*sxR/2+2,size*syR/2*squish+2,0,0,TAU);X.stroke();
    }

    // eyes (not for bonus)
    if(e.t!=="bonus"){
      X.fillStyle=pal("#fff",fog);
      X.fillRect(sx0+size*sxR*.3,sy0+size*syR*.35,size*sxR*.12,size*syR*.15);
      X.fillRect(sx0+size*sxR*.55,sy0+size*syR*.35,size*sxR*.12,size*syR*.15);
      X.fillStyle=pal("#000",fog);
      X.fillRect(sx0+size*sxR*.33,sy0+size*syR*.4,size*sxR*.06,size*syR*.08);
      X.fillRect(sx0+size*sxR*.58,sy0+size*syR*.4,size*sxR*.06,size*syR*.08);
    }

    // type label + due tag
    const lbl=tp.n+(e.small?" JR":"")+(e.due?" DUE":"");
    txt(lbl,ecx-20,sy0-18,e.due?"#ff6666":pal(tp.c,fog),"10px monospace");

    // amount (bonus shows reward with +)
    if(e.t==="bonus"){
      txt("$"+(e.P|0)+" +$"+(e.reward||0),ecx-28,sy0-6,exec?"#ffd700":"#4cff4c","11px monospace");
    }else{
      txt("$"+(e.P|0),ecx-16,sy0-6,exec?"#ffd700":"#fff","12px monospace");
    }
    // bnpl future fee indicator
    if(e.t==="bnpl"&&e.futureFee>0){
      txt("+"+(e.futureFee||0)+"fee",ecx-16,sy0+size*syR+14,pal("#ff9800",fog),"9px monospace");
    }
  }

  // projectiles
  for(const p of projs){
    const vx=p.x-px,vy=p.y-py,d=Math.hypot(vx,vy);
    const ang=Math.atan2(vy,vx);
    let da=Math.atan2(Math.sin(ang-pa),Math.cos(ang-pa));
    if(Math.abs(da)>fov*.6)continue;
    const cx=(0.5+da/fov)*rw;
    const sx0=cx*sxR;
    const y0=H*.52-(40/d);
    X.fillStyle="#ff4444";X.fillRect(sx0-3,y0-3,6,6);
    X.fillStyle="#ff8888";X.fillRect(sx0-1,y0-1,3,3);
  }

  // first person weapon (right hand)
  const gunX=W*.7,gunY=H*.68;
  const rec=recoilT>0?recoilT*60:0;
  // hand
  X.fillStyle="#d8a060";
  X.fillRect(gunX+20,gunY+24-rec,40,28);
  // gun body
  X.fillStyle="#444";
  X.fillRect(gunX-rec*2,gunY,76,22);
  X.fillStyle="#666";
  X.fillRect(gunX+30-rec*2,gunY-10,30,14);
  // barrel
  X.fillStyle="#333";
  X.fillRect(gunX-20-rec*2,gunY+4,24,14);
  // muzzle flash
  if(muzzleT>0){
    X.fillStyle="#ffcc33";X.globalAlpha=muzzleT*12;
    X.fillRect(gunX-36,gunY,18,22);
    X.fillStyle="#fff";X.fillRect(gunX-30,gunY+6,8,10);
    X.globalAlpha=1;
  }

  // HUD - weapon selector
  const bw=62,bh=28,by=6,bx0=W*.5-(bw*3+10*2)/2;
  for(let i=0;i<3;i++){
    const bx=bx0+i*(bw+10);
    X.fillStyle=i===curW?"#ffd700":"#333";X.globalAlpha=i===curW?1:.6;
    X.fillRect(bx,by,bw,bh);
    X.globalAlpha=1;X.strokeStyle="#888";X.strokeRect(bx,by,bw,bh);
    txt(WEAPONS[i].id,bx+4,by+14,i===curW?"#000":"#fff","11px monospace");
    txt("$"+WEAPONS[i].shotCost,bx+4,by+24,i===curW?"#333":"#aaa","9px monospace");
  }

  // HUD info
  const balCol=bal<300?"#ff4444":bal<800?"#ffaa00":"#44ff44";
  txt("BAL: $"+(bal|0),10,bh+22,balCol,"16px monospace");
  if(state==="GAME"){
    txt("LV"+(lvl+1)+" "+LVLS[lvl].name,10,bh+40,"#aaa","11px monospace");
    txt("DMG:"+WEAPONS[curW].damage+" CAP:"+WEAPONS[curW].settleCap,10,bh+54,"#888","10px monospace");
    if(stormOn){txtC("LATE-FEE STORM x2",H*.12,"#ff4444","14px monospace")}
  }
  if(state==="TUTORIAL")txt("TUTORIAL",10,bh+40,"#aaa","11px monospace");

  // door status
  if(!doorOpen){
    const dl=dueLeft();
    txt("EXIT LOCKED - "+dl+" DUE",W-160,bh+22,"#ff6666","11px monospace");
  }else{
    txt("EXIT OPEN!",W-110,bh+22,"#44ff44","12px monospace");
  }

  // EXECUTION LINE bar
  let execAny=alive.some(e=>e.P>0&&e.P<=WEAPONS[curW].settleCap&&bal>=WEAPONS[curW].shotCost);
  if(execAny){
    const ew=240,eh=22;
    X.fillStyle="rgba(255,215,0,.85)";X.fillRect(W/2-ew/2,H-eh-60,ew,eh);
    txt("EXECUTION LINE",W/2-70,H-64,"#000","13px monospace");
  }

  // world EXIT marker
  if(doorOpen){
    const evx=ex-px,evy=ey-py,ed=Math.hypot(evx,evy);
    const eang=Math.atan2(evy,evx);
    const eda=Math.atan2(Math.sin(eang-pa),Math.cos(eang-pa));
    if(Math.abs(eda)<fov*.55&&ed>.2){
      const ecxW=(0.5+eda/fov)*rw*sxR;
      const ecyW=H*.45-(40/ed);
      const esz=clamp(28/ed,10,28);
      X.fillStyle="rgba(0,0,0,.5)";X.fillRect(ecxW-esz*1.2,ecyW-esz*.8,esz*2.8,esz*1.2);
      X.fillStyle="#44ff44";X.font="bold "+esz+"px monospace";
      X.fillText("EXIT",ecxW-esz*.9,ecyW);
    }
  }

  // interest tick flash
  if(flash>0){X.fillStyle="rgba(255,50,50,"+(flash*2)+")";X.fillRect(0,0,W,H)}
  // damage flash
  if(dmgFlash>0){X.fillStyle="rgba(255,0,0,"+(dmgFlash*3)+")";X.fillRect(0,0,W,H)}

  // controls
  // joystick
  X.strokeStyle="rgba(255,255,255,.35)";X.lineWidth=2;
  X.beginPath();X.arc(JX(),JY(),JR(),0,TAU);X.stroke();
  X.fillStyle="rgba(255,255,255,.15)";X.beginPath();X.arc(JX()+moveX*JR()*.6,JY()-moveY*JR()*.6,JR()*.45,0,TAU);X.fill();
  X.strokeStyle="rgba(255,255,255,.4)";X.stroke();

  // fire button
  X.fillStyle=fireHold?"rgba(255,80,80,.4)":"rgba(255,255,255,.08)";
  X.beginPath();X.arc(FX(),FY(),FR(),0,TAU);X.fill();
  X.strokeStyle=fireHold?"#ff4444":"rgba(255,255,255,.4)";X.lineWidth=2;X.stroke();
  txt("FIRE",FX()-16,FY()+5,fireHold?"#ff4444":"#fff","14px monospace");

  // tutorial prompts
  if(state==="TUTORIAL"){
    const py2=H*.35;
    X.fillStyle="rgba(0,0,0,.7)";
    if(tutStep===0){
      X.fillRect(W/2-140,py2-20,280,40);
      txtC("Step 1: MOVE toward the enemy",py2+4,"#4caf50","14px monospace");
      // arrow
      X.fillStyle="#4caf50";
      X.beginPath();X.moveTo(W/2+60,py2);X.lineTo(W/2+80,py2-8);X.lineTo(W/2+80,py2+8);X.fill();
    }else if(tutStep===1){
      X.fillRect(W/2-160,py2-20,320,40);
      txtC("Step 2: FIRE costs money! Tap FIRE",py2+4,"#ffaa00","14px monospace");
    }else if(tutStep===2){
      X.fillRect(W/2-160,py2-20,320,40);
      txtC("Step 3: Keep shooting to weaken it",py2+4,"#ff6666","14px monospace");
    }else if(tutStep===3){
      X.fillRect(W/2-170,py2-20,340,50);
      txtC("EXECUTION LINE! Fire to settle!",py2+4,"#ffd700","15px monospace");
      txtC("One shot clears the debt!",py2+22,"#ffd700","12px monospace");
    }else if(tutStep===4){
      X.fillRect(W/2-140,py2-20,280,40);
      txtC("Step 4: Run to EXIT!",py2+4,"#44ff44","15px monospace");
    }
  }

  X.restore();
}

// ===== DRAW MENU =====
function drawMenu(){
  X.fillStyle="#0a0a0a";X.fillRect(0,0,W,H);
  // background atmosphere
  const t=performance.now()*.001;
  for(let i=0;i<40;i++){
    const x=(Math.sin(t+i*.7)*W*.3+W*.5+i*17)%W;
    const y=(Math.cos(t*.5+i*.5)*H*.2+H*.4+i*11)%H;
    X.fillStyle="rgba("+(i%2?50:30)+",0,0,.15)";
    X.fillRect(x,y,4+i%3,4+i%2);
  }
  // title
  X.fillStyle="#ffd700";X.font="bold 32px monospace";
  const tw=X.measureText("DARK DOOM BAY").width;
  X.fillText("DARK DOOM BAY",W/2-tw/2,H*.22);
  // underline
  X.fillStyle="#ffd700";X.fillRect(W/2-tw/2,H*.23+4,tw,2);
  // subtitle
  txtC("Balance is your blood.",H*.30,"#aa8844","14px monospace");
  // version
  txtC("v1.0",H*.35,"#555","10px monospace");

  // buttons
  const bw=200,bh=44;
  const labels=["START","TUTORIAL","OPTIONS"];
  const colors=["#2a5a2a","#2a3a5a","#3a3a3a"];
  for(let i=0;i<3;i++){
    const bx=W/2-bw/2,by=H*.45+i*60;
    X.fillStyle=colors[i];X.fillRect(bx,by,bw,bh);
    X.strokeStyle="#888";X.lineWidth=1;X.strokeRect(bx,by,bw,bh);
    X.fillStyle="#fff";X.font="16px monospace";
    const m=X.measureText(labels[i]);
    X.fillText(labels[i],bx+bw/2-m.width/2,by+bh/2+6);
  }

  // footer
  txtC("Touch to play | WASD + Space on desktop",H*.92,"#444","10px monospace");
}

// ===== DRAW WIN =====
function drawWin(){
  X.fillStyle="#0a1a0a";X.fillRect(0,0,W,H);
  txtC("YOU WIN!",H*.2,"#ffd700","bold 36px monospace");
  txtC("All debts settled.",H*.3,"#44ff44","16px monospace");
  txtC("Final Balance: $"+(finalBal|0),H*.38,"#ffd700","18px monospace");
  txtC("Time: "+(totalTime|0)+"s",H*.44,"#aaa","14px monospace");
  const bw=180,bh=44,bx=W/2-bw/2;
  btn("PLAY AGAIN",bx,H*.55,bw,bh,"#2a5a2a");
  btn("MENU",bx,H*.55+56,bw,bh,"#3a3a3a");
}

// ===== DRAW LOSE =====
function drawLose(){
  X.fillStyle="#1a0000";X.fillRect(0,0,W,H);
  txtC("BANKRUPT",H*.22,"#ff4444","bold 36px monospace");
  txtC("Your balance hit $0.",H*.32,"#ff6666","16px monospace");
  txtC("The debts consumed you.",H*.4,"#aa4444","13px monospace");
  const bw=180,bh=44,bx=W/2-bw/2;
  btn("RETRY",bx,H*.55,bw,bh,"#5a2a2a");
  btn("MENU",bx,H*.55+56,bw,bh,"#3a3a3a");
}

// ===== DRAW OPTIONS (placeholder) =====
let showOpts=0;
function drawOptions(){
  X.fillStyle="rgba(0,0,0,.85)";X.fillRect(0,0,W,H);
  txtC("OPTIONS",H*.2,"#fff","bold 24px monospace");
  txtC("Sound: ON",H*.38,"#aaa","14px monospace");
  txtC("Sensitivity: MEDIUM",H*.46,"#aaa","14px monospace");
  txtC("(Tap anywhere to close)",H*.6,"#666","12px monospace");
}

// ===== MAIN LOOP =====
let last=performance.now();
function loop(t){
  const dt=Math.min(.05,(t-last)/1000);last=t;dtCur=dt;

  // process taps for menus
  if(tapped){
    tapped=0;
    if(state==="MENU"){
      if(showOpts){showOpts=0}
      else{
        const h=menuHit(tapX,tapY);
        if(h===0||h===1){
          loadTutorial();totalTime=0;
        }else if(h===2){showOpts=1}
      }
    }else if(state==="WIN"){
      const h=endScreenHit(tapX,tapY);
      if(h===0){state="GAME";loadLevel(0);totalTime=0}
      else if(h===1)state="MENU";
    }else if(state==="LOSE"){
      const h=endScreenHit(tapX,tapY);
      if(h===0){state="GAME";loadLevel(lvl)}
      else if(h===1)state="MENU";
    }
    tapX=tapY=-1;
  }

  // detect tutorial shot
  if(state==="TUTORIAL"&&fireHold&&!tutShotFired&&tutStep>=1){tutShotFired=1}

  if(state==="GAME")updateGame(dt);
  else if(state==="TUTORIAL"){
    updateTutorial(dt);
    // tutorial exit
    if(doorOpen&&cell(px|0,py|0)==="E"){
      state="GAME";loadLevel(0);tutDone=1;
    }
  }

  // draw
  if(state==="MENU"){drawMenu();if(showOpts)drawOptions()}
  else if(state==="GAME"||state==="TUTORIAL")drawGame();
  else if(state==="WIN")drawWin();
  else if(state==="LOSE")drawLose();

  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);
</script></body></html>
